<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="color-scheme" content="light dark">

    
      <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;">

    

    <meta name="author" content="levi">
    <meta name="description" content="
  什么是虚拟DOM，怎么构成的
  
    
  

虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成
  &lt;div id=&#34;app&#34;&gt;
    &lt;p class=&#34;text&#34;&gt;hello world!!!&lt;/p&gt;
  &lt;/div&gt;

  // 可转化成下面的虚拟DOM表示
  {
    tag: &#39;div&#39;,
    props: {
      id: &#39;app&#39;
    },
    chidren: [
      {
        tag: &#39;p&#39;,
        props: {
          className: &#39;text&#39;
        },
        chidren: [
          &#39;hello world!!!&#39;
        ]
      }
    ]
  }
上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="levi-react总结"/>
<meta name="twitter:description" content="
  什么是虚拟DOM，怎么构成的
  
    
  

虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成
  &lt;div id=&#34;app&#34;&gt;
    &lt;p class=&#34;text&#34;&gt;hello world!!!&lt;/p&gt;
  &lt;/div&gt;

  // 可转化成下面的虚拟DOM表示
  {
    tag: &#39;div&#39;,
    props: {
      id: &#39;app&#39;
    },
    chidren: [
      {
        tag: &#39;p&#39;,
        props: {
          className: &#39;text&#39;
        },
        chidren: [
          &#39;hello world!!!&#39;
        ]
      }
    ]
  }
上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图"/>

    <meta property="og:title" content="levi-react总结" />
<meta property="og:description" content="
  什么是虚拟DOM，怎么构成的
  
    
  

虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成
  &lt;div id=&#34;app&#34;&gt;
    &lt;p class=&#34;text&#34;&gt;hello world!!!&lt;/p&gt;
  &lt;/div&gt;

  // 可转化成下面的虚拟DOM表示
  {
    tag: &#39;div&#39;,
    props: {
      id: &#39;app&#39;
    },
    chidren: [
      {
        tag: &#39;p&#39;,
        props: {
          className: &#39;text&#39;
        },
        chidren: [
          &#39;hello world!!!&#39;
        ]
      }
    ]
  }
上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-16T13:27:27+08:00" />
<meta property="article:modified_time" content="2021-12-16T13:27:27+08:00" />



    <title>
  levi-react总结 · levi
</title>

    
      <link rel="canonical" href="http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.ccbbada2e264e4fdbf9b2181cccc2cdb289a63dc9520a1e96ac2b9a45778df29.css" integrity="sha256-zLutouJk5P2/myGBzMws2yiaY9yVIKHpasK5pFd43yk=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.90.1" />

    <link href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" rel="stylesheet">
  </head>

  
  
    
  
  <body class="preload-transitions colorscheme-auto">
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      levi
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/">首页</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">博客</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/tags/">标签</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于我</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/">
              levi-react总结
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2021-12-16T13:27:27&#43;08:00'>
                December 16, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              6-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/react/">react</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/react/">react</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <h4 id="什么是虚拟dom怎么构成的">
  什么是虚拟DOM，怎么构成的
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9fdom%e6%80%8e%e4%b9%88%e6%9e%84%e6%88%90%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  &lt;div id=<span style="font-style:italic">&#34;app&#34;</span>&gt;
    &lt;p <span style="font-weight:bold">class</span>=<span style="font-style:italic">&#34;text&#34;</span>&gt;hello world!!!&lt;<span style="">/p&gt;</span>
  &lt;<span style="">/div&gt;</span>

  <span style="font-style:italic">// 可转化成下面的虚拟DOM表示
</span><span style="font-style:italic"></span>  {
    tag: <span style="font-style:italic">&#39;div&#39;</span>,
    props: {
      id: <span style="font-style:italic">&#39;app&#39;</span>
    },
    chidren: [
      {
        tag: <span style="font-style:italic">&#39;p&#39;</span>,
        props: {
          className: <span style="font-style:italic">&#39;text&#39;</span>
        },
        chidren: [
          <span style="font-style:italic">&#39;hello world!!!&#39;</span>
        ]
      }
    ]
  }
</code></pre></div><p>上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图</p>
<h5 id="react">
  react
  <a class="heading-link" href="#react">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>主流的虚拟DOM库都有一个h函数，用于降虚拟DOM，转化为真实DOM, react通过babel把jsx转换成h函数形式，即： react_createElement函数， 最后调用render函数将虚拟DOM插入htmlDOM树中，渲染页面。
示例代码通过babel编译jsx转换成react可处理的结构</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">
  <span style="font-weight:bold">const</span> Page = () =&gt; {
    <span style="font-weight:bold">return</span> &lt;div 
            className=<span style="font-style:italic">&#34;levi&#34;</span>
            style={{margin: <span style="font-style:italic">&#39;100px&#39;</span>}} 
            onClick={onClick}
            &gt;hello world&lt;<span style="">/div&gt;</span>
    }

  <span style="font-weight:bold">export</span> <span style="font-weight:bold">default</span> Page

  <span style="font-style:italic">// babel编译后
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">const</span> Page = () =&gt; {
    <span style="font-weight:bold">return</span> <span style="font-style:italic">/*#__PURE__*/</span>_react.<span style="font-weight:bold">default</span>.createElement(<span style="font-style:italic">&#34;div&#34;</span>, {
      className: <span style="font-style:italic">&#34;levi&#34;</span>,
      style: {
        margin: <span style="font-style:italic">&#39;100px&#39;</span>
      },
      onClick: onClick
    }, <span style="font-style:italic">&#34;hello world&#34;</span>);
  };

  <span style="font-weight:bold">var</span> _default = Page;
</code></pre></div><h4 id="谈谈你对diff算法理解">
  谈谈你对DIFF算法理解
  <a class="heading-link" href="#%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9diff%e7%ae%97%e6%b3%95%e7%90%86%e8%a7%a3">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>顾名思义：就是比较新老VDOM变化，把变化的部分更新到视图上<br>
<strong>diff的优化策略</strong></p>
<ul>
<li>针对于tree diff优化，react会忽略DOM节点跨层级的移动操作</li>
<li>针对于组件 diff优化，如果是不同的组件就会生成不同的组件，所以如果是不同的组件，就会被标记要修改，而不再细致的比较</li>
<li>针对于同一层级的一组子节点，可以通过对应的key进行区别</li>
</ul>
<h5 id="tree-diff">
  tree diff
  <a class="heading-link" href="#tree-diff">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>针对于dom跨层级移动操作，diff算法会对相同层级的节点比较，如果某个节点不存在了，那么这个节点和其子节点是不会再有比较的，react只会考虑同层级的节点的位置变化，而对于不同层级的节点，只有创建和删除。如果某个节点下发现某个子节点A消失了，就会直接销毁子节点A。
<!-- raw HTML omitted --></p>
<h5 id="component-diff">
  component diff
  <a class="heading-link" href="#component-diff">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>如果是同一类型的组件，则会比较虚拟dom树，如果不是同一类型，那么这个组件将被标记为dirty组件，从而替换整个组件下的所有子节点。如果是同一类型的组件，可能存在虚拟dom没有任何变化，因此react通过shouldComponentUpdate来判断这个组件是否需要进行diff运算, 如下图，一旦react判断D和G是不同类型的组件，就不会比较两者的结构，而是直接删除componentD，重新创建组件G及其子节点
<!-- raw HTML omitted --></p>
<h5 id="element-diff">
  element diff
  <a class="heading-link" href="#element-diff">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>当节点处于同一级时，diff提供三种节点操作：插入，移动，删除, 如下图，老集合节点顺序为：a,b,c,d，新节点的顺序为：b,a,d,c。如果是传统的diff操作，那么就会对比老A和新B，发现B!=A于是创建并插入B至最新的集合中，删除老集合中的A，以此类推。
<!-- raw HTML omitted -->
React提出，通过key来判断同一层级的同组子节点。如果是相同的节点，只需要移动位置即可
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->react主要用key来区分组件，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新。如果key不同，react会销毁已有的组件实例，重新创建组件新的实例<!-- raw HTML omitted --></p>
<h4 id="生命周期有哪些">
  生命周期有哪些
  <a class="heading-link" href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%9c%89%e5%93%aa%e4%ba%9b">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>react &gt; 16.3版本最新的生命周期,<br>
<!-- raw HTML omitted --></p>
<p>移除了3个生命周期</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReciveProps</li>
<li>componentWillUpdate</li>
</ul>
<p>新增了2个生命周期</p>
<ul>
<li>static getDerivedStateFromProps</li>
<li>getSnapshotBeforeUpdate</li>
</ul>
<p>我们将react生命周期化为为三个阶段，分别是</p>
<ul>
<li>挂载阶段 Mouting</li>
<li>更新阶段 Update</li>
<li>卸载阶段 unMount</li>
</ul>
<h5 id="挂载阶段">
  挂载阶段
  <a class="heading-link" href="#%e6%8c%82%e8%bd%bd%e9%98%b6%e6%ae%b5">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>组件初始化阶段，这个阶段只会执行一次，有以下生命周期方法，顺序如下</p>
<ul>
<li>constructor</li>
<li>staic getDerivedStateFromProps</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<blockquote>
<p>constructor 构造函数，初始化阶段被执行，如果使用了构造函数，需要在内部执行super(props)，不然会报错，
在构造函数常做以下2件事情</p>
</blockquote>
<ul>
<li>初始化state对象</li>
<li>自定义事件(合成事件)绑定this</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">class</span> Levi <span style="font-weight:bold">extends</span> React.Component{
    constructor(props) {
      <span style="font-weight:bold">super</span>(props);
      
      <span style="font-weight:bold">this</span>.handleClick = <span style="font-weight:bold">this</span>.handleClick.bind(<span style="font-weight:bold">this</span>);
    }
  }

</code></pre></div><blockquote>
<p>getDerivedStateFromProps react实例的静态方法，<!-- raw HTML omitted -->不能在该方法中使用this<!-- raw HTML omitted -->，接受2个参数： 即使 getDerivedStateFromProps(nextProps, prevState)
这个函数会返回一个对象用于更新当前state,如果返回null，则不更新state</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">class</span> Levi <span style="font-weight:bold">extends</span> React.Componet {
    state: {
      age: 20
    }

    <span style="font-weight:bold">static</span> getDerivedStateFromProps(nextProps, prevState) {
      <span style="font-weight:bold">if</span> (nextProps.currentRow !== prevState.lastRow) {
        <span style="font-weight:bold">return</span> {
            lastRow: nextProps.currentRow
        }
      }

      <span style="font-weight:bold">return</span> <span style="font-weight:bold">null</span>
    }
  }
</code></pre></div><blockquote>
<p>render react最核心方法，一个组件中必须有这个方法，是一个纯函数，返回需要被渲染的元素，不要这个方法包含业务逻辑，例如数据请求，可能会造成重复渲染，页面卡死</p>
</blockquote>
<blockquote>
<p>componentDidMount  组件装修后调用，常用于数据请求，获取并操作DOM。可以写一些订阅操作，但是记得在componentWillUnMount 取消订阅</p>
</blockquote>
<h5 id="更新阶段">
  更新阶段
  <a class="heading-link" href="#%e6%9b%b4%e6%96%b0%e9%98%b6%e6%ae%b5">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>组件props、state发生改变，会触发该阶段</p>
<ul>
<li>getDevrvedStateFromProps</li>
<li>shouldCompoentUpdate</li>
<li>render</li>
<li>getSnapShotBeforeUpdate</li>
<li>componentDidUpdate</li>
</ul>
<blockquote>
<p>getDevrvedStateFromProps 同上</p>
</blockquote>
<blockquote>
<p>shouldCompnentUpdate 接受2个函数 为 shouldCompnentUpdate(nextProps, nextState)会返回一个boolean， true表示执行更新，页面渲染， false表示页面不会渲染, 默认返回true
<!-- raw HTML omitted -->注意当我们调用forceUpdate并不会触发此方法<!-- raw HTML omitted -->。不建议手工编写shouldCompnentUpdate逻辑，除非牵扯到复杂的深度比较&lt;shouldComponentUpdate默认浅层比较props,state, 可在方法内部自定义比较逻辑&gt;，官方推荐使用 React.PureComponent&lt;浅层比较props,state&gt;</p>
</blockquote>
<blockquote>
<p>render 同上</p>
</blockquote>
<blockquote>
<p>getSnopShotBeforeUpdate 这个方法在render之后、componentDidUpdate之前，它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置。 有2个参数： getSnapShotBeforeUpdate(prevProps, prevState), 函数会返回一个值，会作为低三个参数传递给componentDidUpdate. 如果没有返回值，请返回null，不然控制台会有警告，并且componentDidUpdate不能缺少，不然也会警告。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">
    <span style="font-style:italic">// 限制聊天气泡框scrollTop: https://kinyaying.github.io/webpack-optimize/dist/#/snapshotSampleOptimize
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">class</span> Levi <span style="font-weight:bold">extends</span> React.Componet {
    getSnapshotBeforeUpdate(prevProps, prevState) {
      state =  {
          newList: []
      }

      leviRef = React.crateRef();

      <span style="font-weight:bold">if</span> (prevProps.list.length &lt; <span style="font-weight:bold">this</span>.state.newList.length) {
        <span style="font-weight:bold">return</span> <span style="font-weight:bold">this</span>.leviRef.scrollHeight;
      }

      <span style="font-weight:bold">return</span> <span style="font-weight:bold">null</span>;
    }

    componentDidUpdate(prevProps, prevState, perScrollHeight) {
      <span style="font-weight:bold">if</span>(!snopShot) {
        console.log(<span style="font-style:italic">&#39;这里是getSnapShotBeforeUpdate 拿到返回值&#39;</span>)
        
        <span style="font-weight:bold">const</span> curScrollTop= <span style="font-weight:bold">this</span>.leviRef.scrollTop;
        <span style="font-weight:bold">if</span> (curScrollTop &lt; 5) <span style="font-weight:bold">return</span> ;
        <span style="font-weight:bold">this</span>.leviRef.scrollTop = curScrollTop + (<span style="font-weight:bold">this</span>.rootNode.scrollHeight  - perScrollHeight);   <span style="font-style:italic">//加上增加的div高度，就相当于不动
</span><span style="font-style:italic"></span>      }
    }
  }
</code></pre></div><blockquote>
<p>componentDidUpdate 发生在getShapShotBeforeUpdate之后，接受3个参数分为： componentUpdate(prevProps, prevState, snapshot)
在这个函数里面可以进行DOM操作和数据请求，但是请注意，如果setState。 一定要写if判断逻辑，不然会造成死循环，页面卡死</p>
</blockquote>
<p>参考文章</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/370198189">React 17生命周期总结</a></li>
</ul>
<h5 id="卸载阶段">
  卸载阶段
  <a class="heading-link" href="#%e5%8d%b8%e8%bd%bd%e9%98%b6%e6%ae%b5">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ul>
<li>componentWillUnmount</li>
</ul>
<blockquote>
<p>componentWillUnmount 组件卸载时调用， 可取消订阅、清除定时器、清除组件内部引用store的数据等操作</p>
</blockquote>
<h4 id="setstate">
  setState
  <a class="heading-link" href="#setstate">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的</li>
<li>setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果</li>
<li>在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</li>
</ul>
<blockquote>
<p>setState 是通过 enqueueUpdate 来执行 state 更新的，那 enqueueUpdate 是如何实现更新 state 的？继续往下走。
3、enqueueUpdate 如果当前正处于创建/更新组件的过程，就不会立刻去更新组件，而是先把当前的组件放在 dirtyComponent 里，这里也很好的解释了上面的例子，不是每一次的 setState 都会更新组件。否则执行 batchedUpdates 进行批量更新组件；</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">enqueueSetState: <span style="font-weight:bold">function</span>(publicInstance, partialState, ...) {
  <span style="font-weight:bold">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
  <span style="font-weight:bold">if</span> (internalInstance) {
    (internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = [])).push(partialState), 
    enqueueUpdate(internalInstance);
  }
}

<span style="font-weight:bold">function</span> enqueueUpdate(component) {
 <span style="font-style:italic">// ...  
</span><span style="font-style:italic"></span> <span style="font-weight:bold">if</span> (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    <span style="font-weight:bold">return</span>;
  }

  dirtyComponents.push(component);
}
</code></pre></div><p>setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果</p>
<!-- raw HTML omitted -->
<p>参考文章</p>
<ul>
<li><a href="https://juejin.cn/post/6844903715921477640#heading-2">setState异步、同步与进阶</a></li>
<li><a href="https://github.com/JTangming/blog/issues/11">关于 React setState，你了解多少？ #11</a></li>
</ul>
<h4 id="类组件和函数组件区别">
  类组件和函数组件区别
  <a class="heading-link" href="#%e7%b1%bb%e7%bb%84%e4%bb%b6%e5%92%8c%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>类组件就是常说的class组件，有声明周期以及state <br>
函数式组件：无声明周期，可接受props，常用来作为UI组件，</p>
<blockquote>
<p>函数式组件性能比类组件要高，适用于表现层，类组件包含声明周期以及state特性，可处理复杂的逻辑，适用于逻辑层。<!-- raw HTML omitted -->react初衷偏向于使用函数式组件，这样能更快的渲染。hooks横空出世<!-- raw HTML omitted --></p>
</blockquote>
<h4 id="react-ref作用">
  react ref作用
  <a class="heading-link" href="#react-ref%e4%bd%9c%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>dom元素、组件真正实例的引用，其实就是react.render()函数执行后，返回的<strong>组件实例</strong>， <!-- raw HTML omitted -->你不能在函数组件上使用 ref 属性，因为他们没有实例。<!-- raw HTML omitted --></p>
<ul>
<li>
<p>为什么会用到refs
当要处理DOM元素的时候，例如元素focus,文本的选择，媒体的播放，第三方dom库集成，特性情况获取元素的宽高度等，这些是react无法控制的局面，所以需要用到ref</p>
</li>
<li>
<p>如何创建ref</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="font-style:italic">&lt;!--</span> react createRef --&gt;
<span style="font-weight:bold">class</span> Levi <span style="font-weight:bold">extends</span> React.Component {
  constructor(props) {
    <span style="font-weight:bold">this</span>.leviRef = React.createRef();
  }

  <span style="font-weight:bold">private</span> init() {
    console.log(<span style="font-weight:bold">this</span>.leviRef)
  }

  render() {
    <span style="font-weight:bold">return</span> &lt;div ref={<span style="font-weight:bold">this</span>.leviRef}&gt;hello world&lt;<span style="">/div&gt;;</span>
  }
}

<span style="font-style:italic">&lt;!--</span> hooks --&gt;
<span style="font-weight:bold">const</span> Page = () =&gt; {
  <span style="font-weight:bold">const</span> leviRef = useRef(initialVal);

  <span style="font-weight:bold">const</span> fetch = useCallback(() =&gt; {
    console.log(leviRef.current)
  }, [])

  <span style="font-weight:bold">return</span>  &lt;div ref={<span style="font-weight:bold">this</span>.leviRef}&gt;hello world&lt;<span style="">/div&gt;;</span>
}
</code></pre></div></li>
<li>
<p>访问ref
当ref传递给render元素时，対该元素的引用可在ref中的current获取到</p>
</li>
</ul>
<blockquote>
<p>const ref = this.leviRef.current</p>
</blockquote>
<h4 id="什么是高阶组件">
  什么是高阶组件？
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>高阶组件可接受react组件作为参数并返回一个新的组件的函数，
高阶组件可用于以下场景</p>
<ul>
<li>代码复用，逻辑抽象</li>
<li>渲染劫持</li>
<li>props处理，</li>
<li>state抽象、操作</li>
<li>可用过ref访问该组件的实例</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">
<span style="font-weight:bold">const</span> HOCComponent = (WrapComponent) =&gt; {
  <span style="font-weight:bold">return</span> <span style="font-weight:bold">class</span> HOCComponent <span style="font-weight:bold">extends</span> React.Component {
      state = {
        name: <span style="font-style:italic">&#39;levi&#39;</span>,
        age: 20
      }
      levi = React.createRef();

      componentDidMount() {
        console.log(<span style="font-weight:bold">this</span>.levi.current); <span style="font-style:italic">// 打印组件实例
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">this</span>.setState({age: 21}) <span style="font-style:italic">// fecth data
</span><span style="font-style:italic"></span>      }

      render() {
        <span style="font-weight:bold">const</span> newProps = {
          area: <span style="font-style:italic">&#39;sh&#39;</span>
        }

        <span style="font-style:italic">// 起到权限控制作用，不用再每个月页面里面判断
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">if</span>(<span style="font-weight:bold">this</span>.state.age &lt; 18) {
          <span style="font-weight:bold">return</span> &lt;div&gt;未成年人无权限进入&lt;<span style="">/div&gt;</span>
        }

        <span style="font-weight:bold">return</span> &lt;div&gt;&lt;WrapComponent {...newProps} {...state} ref={<span style="font-weight:bold">this</span>.levi} /&gt;&lt;div&gt;
      }
  }
}
</code></pre></div><h4 id="什么是jsx">
  什么是jsx
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%afjsx">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li>
<p>优点、特点</p>
<ul>
<li>增强可读性</li>
<li>语法上和HTML非常相似</li>
<li>允许自定义标签以及组件</li>
<li>抽象可读性，react进行升级，不需要改动任何jsx代码</li>
<li>模块化，保证了组件中的标签与业务逻辑相分离</li>
</ul>
</li>
<li>
<p>jsx和html之间的不同</p>
<ul>
<li>jsx可以使用变量属性</li>
<li>事件要使用驼峰式写法</li>
<li>html使用的是class，而jsx使用的是className</li>
<li>style的css属性要使用驼峰式写法</li>
</ul>
</li>
<li>
<p>jsx 会经历什么，变成什么样子，怎么渲染到页面的
jsx会经过bable编译+react.js构造，变成js对象（这个对象也就是我们说的虚拟dom），然后通过ReactDOM.render进行创建DOM元素，然后将DOM插入到浏览器中</p>
</li>
<li>
<p>jsx为什么要经历一层bable编译呢？
jsx是一个抽象出来的语法，它经过bable编译以后，可以变成一个可以描述UI的对象，我们可以拿着这个对象，渲染到浏览器，也可以选择显示到手机APP，所以这也是为什么要把react-dom单独抽离出来</p>
</li>
</ul>
<h4 id="什么是reactcontext">
  什么是React.Context
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%afreactcontext">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>context的作用就是实现跨层级的组件数据传递， context提供了一种在组件之间可以共享值的方法，而无需通过树的每个级显示传递props <br>
<strong>优点： 跨组件访问数据</strong>
<strong>缺点：react组件树中某个上级组件shouldComponentUpdate返回false以后，当context更新，是不会引起下级组件的更新</strong></p>
<p>函数式组件React.useContext上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。
即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染</p>
<h5 id="如何创建">
  如何创建
  <a class="heading-link" href="#%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-style:italic">// 创建context上下文，可单独抽离成一个文件
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">const</span> LeviInfoContext = React.createContext({ name: <span style="font-style:italic">&#39;levi&#39;</span>, age: 20, run: () =&gt; console.log(<span style="font-style:italic">&#39;run&#39;</span>) });

  <span style="font-style:italic">// 提供provider包含内组件消费, 接受一个默认值value
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">class</span> App <span style="font-weight:bold">extends</span> React.Component {
    <span style="font-weight:bold">public</span> render() {
      <span style="font-weight:bold">return</span> (
        &lt;LeviInfoContext.Provider value={{ name: <span style="font-style:italic">&#39;levi&#39;</span>, age: 21 }}&gt;
          &lt;App /&gt;
        &lt;<span style="">/LeviInfoContext.Provider&gt;</span>
      );
    }
  }

  <span style="font-style:italic">// 类组件使用consemer消费
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">import</span> LeviInfoContext from <span style="font-style:italic">&#39;xxxx&#39;</span>;
  <span style="font-weight:bold">class</span> Children <span style="font-weight:bold">extends</span> React.Component {
    <span style="font-weight:bold">public</span> render() {
      <span style="font-weight:bold">return</span> &lt;LeviInfoContext.consumer&gt;{(baseObject) =&gt; &lt;div&gt;i am child&lt;<span style="">/div&gt;}&lt;/LeviInfoContext.consumer&gt;;</span>
    }
  }

  <span style="font-style:italic">// 函数式组件使用 React.useContext。接受React.createContext返回的值
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">const</span> Page = () =&gt; {
    <span style="font-weight:bold">const</span> info = React.useContext(LeviInfoContext);

    <span style="font-weight:bold">return</span> &lt;div&gt;11111{info.name}&lt;<span style="">/div&gt;;</span>
  };
</code></pre></div><p><a href="https://juejin.cn/post/6907546624441090055">从Context源码实现谈React性能优化</a></p>
<h4 id="如何避免组件重复渲染">
  如何避免组件重复渲染
  <a class="heading-link" href="#%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>React常见问题就是重复渲染，React提供了2个方法，避免重复渲染</p>
<ul>
<li>React.Memo(component, fn)</li>
<li>React.PureComponent</li>
<li>React.useMemo(fn: () =&gt; Component, deps) &lt;函数式组件常用&gt;</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">
  <span style="font-weight:bold">const</span> ComponentByMemo = React.memo(compoennt, (prevProps, nextProps) =&gt; {
    <span style="font-style:italic">//  如果 props 相等，默认回收函数 会返回 true，并且不更新；如果 props 不相等，则返回 false，组件更新
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// 这与 shouldComponentUpdate 方法的返回值相反， shouldComponent 返回true的话，更新，反正不更新
</span><span style="font-style:italic"></span>  } )

  <span style="font-weight:bold">class</span> Levi <span style="font-weight:bold">extends</span> React.PureComponent {
    render() {
      <span style="font-weight:bold">return</span> &lt;div&gt;levis&lt;<span style="">/div&gt;</span>
    }
  }

  <span style="font-weight:bold">const</span> ComponentByUseMemo = React.useMemo()

</code></pre></div><h4 id="如何提高react性能">
  如何提高react性能
  <a class="heading-link" href="#%e5%a6%82%e4%bd%95%e6%8f%90%e9%ab%98react%e6%80%a7%e8%83%bd">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li>适当的使用shouldComponentUpdate/React.memo，避免了子组件不必要的渲染</li>
<li>在列表和表格中使用key，这样React渲染更新速度更快</li>
<li>抽离公共代码到单独文件中，使用路由懒加载
<strong>补充前端性能优化</strong></li>
<li>减少http请求，缓存相关的ajax数据</li>
<li>图片优化，压缩图片</li>
<li>css优化，提取共有css代码</li>
<li>js优化，提取公共js代码-</li>
<li>使用CDN内容分发网络，</li>
<li>使用响应的打包工具：webpack,gulp压缩代码</li>
<li>DOM渲染优化。重绘不一定引起回流，但是回流会重绘，所以在弄DOM渲染的时候，毕竟发生过多的回流以及重绘</li>
</ul>
<h4 id="什么是reactfiber">
  什么是React.Fiber
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%afreactfiber">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<h4 id="react-事件系统">
  react 事件系统
  <a class="heading-link" href="#react-%e4%ba%8b%e4%bb%b6%e7%b3%bb%e7%bb%9f">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<h4 id="react为什么要引入hooks">
  react为什么要引入hooks
  <a class="heading-link" href="#react%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%bc%95%e5%85%a5hooks">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li>组件之间逻辑复杂难用</li>
<li>大型的组件难以拆分</li>
<li>难以理解的class语法，忘记事件绑定this，没有稳定的语法提案
相对类组件，函数式组件又过于简陋，没有生命周期钩子，没有类组件的状态。但是函数式组件上手简单，友好直观</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">import</span> React, {useState} from <span style="font-style:italic">&#39;react&#39;</span>;

  <span style="font-weight:bold">const</span> Levi = () =&gt; {

    <span style="font-weight:bold">const</span> [count, setCount] = useState&lt;number&gt;(0);

    <span style="font-weight:bold">const</span> handleClick = useCallback(() =&gt; {
      setCount(count+1)
    }, [])

    <span style="font-weight:bold">return</span> &lt;Button onclick={handleClick}&gt;点击&lt;<span style="">/Button&gt;</span>
  }

</code></pre></div><h4 id="常用hooks">
  常用hooks
  <a class="heading-link" href="#%e5%b8%b8%e7%94%a8hooks">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li>useState()状态钩子。为函数组建提供内部状态
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">const</span> Page = () =&gt; {
    <span style="font-weight:bold">const</span> [name, setName] = useState&lt;string&gt;(<span style="font-style:italic">&#39;levi&#39;</span>)
  };
</code></pre></div></li>
<li>useContext()共享钩子。该钩子的作用是，在组件之间共享状态。 可以解决react逐层通过Porps传递数据，它接受React.createContext()的返回结果作为参数，使用useContext将不再需要Provider 和 Consumer
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">const</span> Page = () =&gt; {
    <span style="font-weight:bold">const</span> info = React.useContext(LeviInfoContext);

    <span style="font-weight:bold">return</span> &lt;div&gt;11111{info.name}&lt;<span style="">/div&gt;;</span>
  };
</code></pre></div></li>
<li>useReducer()状态钩子。Action 钩子。useReducer() 提供了状态管理，其基本原理是通过用户在页面中发起action, 从而通过reducer方法来改变state, 从而实现页面和状态的通信。使用很像redux
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">const</span> initialState = { count: 0 };

  <span style="font-weight:bold">function</span> reducer(state, action) {
    <span style="font-weight:bold">switch</span> (action.type) {
      <span style="font-weight:bold">case</span> <span style="font-style:italic">&#39;increment&#39;</span>:
        <span style="font-weight:bold">return</span> { count: state.count + 1 };
      <span style="font-weight:bold">case</span> <span style="font-style:italic">&#39;decrement&#39;</span>:
        <span style="font-weight:bold">return</span> { count: state.count - 1 };
      <span style="font-weight:bold">default</span>:
        <span style="font-weight:bold">throw</span> <span style="font-weight:bold">new</span> Error();
    }
  }

  <span style="font-weight:bold">function</span> Counter() {
    <span style="font-weight:bold">const</span> [state, dispatch] = useReducer(reducer, initialState);
    <span style="font-weight:bold">return</span> (
      &lt;&gt;
        Count: {state.count}
        &lt;button onClick={() =&gt; dispatch({ type: <span style="font-style:italic">&#39;decrement&#39;</span> })}&gt;-&lt;<span style="">/button&gt;</span>
        &lt;button onClick={() =&gt; dispatch({ type: <span style="font-style:italic">&#39;increment&#39;</span> })}&gt;+&lt;<span style="">/button&gt;</span>
      &lt;<span style="">/&gt;</span>
    );
  }
</code></pre></div></li>
<li>useEffect()副作用钩子。它接收两个参数， 第一个是进行的异步操作， 第二个是数组，用来给出Effect的依赖项
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">const</span> Page = () =&gt; {
    useEffect(() =&gt; {
      <span style="font-weight:bold">const</span> initial = <span style="font-weight:bold">async</span> () =&gt; {
        <span style="font-style:italic">// fetch data
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">await</span> Promise.resolve();
      }
    }, [])

  <span style="font-weight:bold">return</span> &lt;div&gt;11111{info.name}&lt;<span style="">/div&gt;;</span>
};
</code></pre></div></li>
<li>useRef()获取组件的实例；渲染周期之间共享数据的存储(state不能存储跨渲染周期的数据，因为state的保存会触发组件重渲染）,useRef传入一个参数initValue，并创建一个对象{ current: initValue }给函数组件使用，在整个生命周期中该对象保持不变
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">const</span> Page = () =&gt; {
    <span style="font-weight:bold">const</span> leviRef = React.useRef(initialVal)

    <span style="font-weight:bold">const</span> handleClick = useCallback(() =&gt; {
      levi.current.focus();
    }, [])

    <span style="font-weight:bold">return</span> &lt;input ref={leviRef} onClick={handleClick} /&gt;
  },
</code></pre></div></li>
<li>useMemo和useCallback可缓存函数的引用或值，useMemo缓存数据(所有对象、包括函数)，useCallback缓存函数，两者是Hooks的常见优化策略，useCallback(fn,deps)相当于useMemo(()=&gt;fn,deps)
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">    <span style="font-weight:bold">const</span> Page = () =&gt; {
      <span style="font-weight:bold">const</span> leviRef = React.useRef(initialVal)

      <span style="font-weight:bold">const</span> handleClick = useCallback(() =&gt; {
        levi.current.focus();
      }, [])

      <span style="font-weight:bold">return</span> React.useMemo(() = &lt;input ref={leviRef} onClick={handleClick} /&gt;, [])
  },
</code></pre></div></li>
</ul>
<h4 id="hooks相比hoc和render-prop有哪些优点">
  Hooks相比HOC和Render Prop有哪些优点？
  <a class="heading-link" href="#hooks%e7%9b%b8%e6%af%94hoc%e5%92%8crender-prop%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%82%b9">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>HOC都属于一种开发模式,将复用逻辑提升至父组件，容易嵌套过多、过度包装
hooks是react一种api, 将复用逻辑提升组件顶层，而不是提升至父组件中，避免造成多层嵌套</p>
<h4 id="hooks-里面有哪些优化方案">
  hooks 里面有哪些优化方案
  <a class="heading-link" href="#hooks-%e9%87%8c%e9%9d%a2%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8c%96%e6%96%b9%e6%a1%88">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li>
<p>deps依赖项不过过多，尽量不要超出3个</p>
</li>
<li>
<p>多个相关state，合并成对象形式处理，不然会导致hooks内部出现多个state，难以维</p>
</li>
<li>
<p>在 useCallback 内部使用了 setState ，可以考虑使用 setState callback 减少依赖</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">const</span> useValues = () =&gt; {
    <span style="font-weight:bold">const</span> [values, setValues] = useState({});

    <span style="font-weight:bold">const</span> updateData = useCallback((nextData) =&gt; {
      setValues((prevValues) =&gt; ({
        data: nextData,
        count: prevValues.count + 1,    
      })); <span style="font-style:italic">// 通过 setState 回调函数获取最新的 values 状态，这时 callback 不再依赖于外部的 values 变量了，因此依赖数组中不需要指定任何值
</span><span style="font-style:italic"></span>    }, []); <span style="font-style:italic">// 这个 callback 永远不会重新创建
</span><span style="font-style:italic"></span>
    <span style="font-weight:bold">return</span> [values, updateData];
  };

</code></pre></div></li>
<li>
<p>可有ref来保存变量(组件整个生命周期ref会保持不变)</p>
</li>
<li>
<p>编写自定义hooks返回可以选择元祖类型，如果超出3个，建议考虑对象形式返回</p>
</li>
<li>
<p>自定义hooks返回的值，要保持引用的一致性</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-weight:bold">function</span> Example() {
    <span style="font-weight:bold">const</span> data = useData();
    <span style="font-weight:bold">const</span> [dataChanged, setDataChanged] = useState(<span style="font-weight:bold">false</span>);

    useEffect(() =&gt; {
      setDataChanged((prevDataChanged) =&gt; !prevDataChanged); 
      <span style="font-style:italic">// 当 data 发生变化时，调用 setState。
</span><span style="font-style:italic"></span>      <span style="font-style:italic">// 如果 data 值相同而引用不同，就可能会产生非预期的结果。 
</span><span style="font-style:italic"></span>    }, [data]);

    console.log(dataChanged);

    <span style="font-weight:bold">return</span> &lt;LeviComponent data={data} /&gt;;
  }

  <span style="font-weight:bold">const</span> useData = () =&gt; {
    <span style="font-style:italic">// 获取异步数据  
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">const</span> resp = getAsyncData([]);

    <span style="font-style:italic">// 处理获取到的异步数据，这里使用了 Array.map。
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// 因此，即使 data 相同，每次调用得到的引用也是不同的。  
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">const</span> mapper = (data) =&gt; data.map((item) =&gt; ({...item, selected: <span style="font-weight:bold">false</span>}));

    <span style="font-weight:bold">return</span> resp ? mapper(resp) : resp;
  };
</code></pre></div></li>
</ul>
<h4 id="usecallback-是用来干嘛的">
  useCallback 是用来干嘛的
  <a class="heading-link" href="#usecallback-%e6%98%af%e7%94%a8%e6%9d%a5%e5%b9%b2%e5%98%9b%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>缓存函数</p>
<h4 id="useeffect和uselayouteffect区别">
  useEffect和useLayoutEffect区别？
  <a class="heading-link" href="#useeffect%e5%92%8cuselayouteffect%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>1、useEffect是render结束后，callback函数执行，但是不会阻断浏览器的渲染。
2、useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制。</p>
<h4 id="react新版生命周期getdrivedstatefromprops为什么是静态的">
  react新版生命周期getDrivedStatefromprops为什么是静态的
  <a class="heading-link" href="#react%e6%96%b0%e7%89%88%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9fgetdrivedstatefromprops%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e9%9d%99%e6%80%81%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>react 16.4版本引入，代替换来的componentWillReceiveProps, 当props或state改变的时候，触发，是一个纯函数。
之所以设置为静态，在函数内部不能获取this，防止setState造成死循环;</p>
<h4 id="实现一个自定义hooks">
  实现一个自定义hooks
  <a class="heading-link" href="#%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e8%87%aa%e5%ae%9a%e4%b9%89hooks">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>注意： 自定义hooks以use开头、或者函数名开头大写(react会认为这是一个组件)。不会react-hooks校验规则会报错</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="font-style:italic">// 获取当前文档标题 &amp;&amp; 设置文档标题
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">import</span> { useState, useEffect, useCallback } from <span style="font-style:italic">&#39;react&#39;</span>;
  <span style="font-weight:bold">const</span> useTitle = () =&gt; {
    <span style="font-weight:bold">const</span> [title, setTitle] = useState&lt;string&gt;(document.title);

    useEffect(() =&gt; {
      document.title = title;
    }, [title]);

    <span style="font-weight:bold">const</span> setDocumentTitle = useCallback(newTitle =&gt; {
      setTitle(newTitle);
    }, []);

    <span style="font-weight:bold">return</span> [title, setDocumentTitle];
  };

  <span style="font-weight:bold">export</span> <span style="font-weight:bold">default</span> useTitle;

  <span style="font-style:italic">// fetch data
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">import</span> { useState, useCallback } from <span style="font-style:italic">&#39;react&#39;</span>;
  <span style="font-weight:bold">const</span> useFetchCity = () =&gt; {
    <span style="font-weight:bold">const</span> [city, setCity] = useState&lt;any[]&gt;([]);
    <span style="font-weight:bold">const</span> [loading, setLoading] = useState&lt;<span style="font-weight:bold">boolean</span>&gt;(<span style="font-weight:bold">false</span>);

    <span style="font-weight:bold">const</span> getAllCity = useCallback(<span style="font-weight:bold">async</span> () =&gt; {
      setLoading(<span style="font-weight:bold">true</span>);

      <span style="font-weight:bold">const</span> res = <span style="font-weight:bold">await</span> <span style="font-weight:bold">new</span> Promise(resolve =&gt; {
        setTimeout(() =&gt; {
          resolve([1, 2, 3, 4]);
        }, 2000);
      });

      setCity(res);
      setLoading(<span style="font-weight:bold">false</span>);
    }, []);

    <span style="font-weight:bold">return</span> [loading, city, getAllCity];
  };

  <span style="font-weight:bold">export</span> <span style="font-weight:bold">default</span> useFetchCity;


</code></pre></div>
      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2021
     levi 
    ·
    开启美好新一天
  </section>
</footer>

    </main>

    
      
      <script src="/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js" integrity="sha256-A7F3afT5GuNWZ&#43;HyocqMFvUFYlds&#43;Q/zKzF5kmkU2qU="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
