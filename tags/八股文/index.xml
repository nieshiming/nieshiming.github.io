<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>八股文 on levi</title>
    <link>https://nieshiming.cn/tags/%E5%85%AB%E8%82%A1%E6%96%87/</link>
    <description>Recent content in 八股文 on levi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 15 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nieshiming.cn/tags/%E5%85%AB%E8%82%A1%E6%96%87/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法 排序</title>
      <link>https://nieshiming.cn/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</guid>
      <description>十大排序算法    冒泡排序    选择排序    快速排序    堆排序    参考文章    图解排序算法(三)之堆排序 javascript实现堆排序</description>
    </item>
    
    <item>
      <title>数据结构 树</title>
      <link>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</link>
      <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</guid>
      <description>树     树是一种非线性结构，它对于存储快速查找的元素非常用有用， 树是一种分层数据的抽象模型
  树的相关术语 树结构实现 树的遍历 添加和移除节点  树的相关术语     位于树顶部的节点叫作根节点。它没有父节点。 树中的每个元素都叫作节点.节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点，没有子元素的节点成为外部节点或叶节点。 节点的深度：取决当前节点去祖先节点的数量。 节点的高度：所有节点深度的最大值  二叉树 &amp;amp; 二叉搜索树（BST树）    二叉树中每个节点最多有个节点，一个是左侧节点，一个是右侧节点
二叉搜索树是二叉树特殊分别，只允许你在左侧存储比父节点小数据，右侧节点存储比父节点大数据
BST实现     insert(key) 向树插入一个新的键 search(key) 在树种搜索key是否存在 remove(key) 删除树种特定的值 min() 寻找树的最小值 max() 寻找树的最大值 preOrderTraverse 先序遍历： 先输出当前节点值，在输出左节点，然后右节点值 middleOrderTraverse 中序遍历： 先输出左侧节点值，在输出当前节点值，然后右节点值 postSequenceTraverse 后续遍历： 先输出左侧节点值，在输出右侧节点值，然后输出当前节点值  class Node { constructor(value) { this.key = value this.left = null this.right = null } } class bstTree { root = null insert(key) { const item = new Node(key) const insertNode = (node, key) =&amp;gt; { if (!</description>
    </item>
    
    <item>
      <title>数据结构 链表篇</title>
      <link>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E7%AF%87/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E7%AF%87/</guid>
      <description>链表    数组&amp;lt;队列&amp;gt;是比较简单的线性存储，数组的大小初始化是固定，从起点和中间插入元素成本很高，因为需要不断的移动元素。 链表存储有序的数据集合，不同于数组的是，链表存储的数据在内存中并不要求是连续的，链表中每个节点存储了当前节点值，以及指向下一个节点的指针
链表可细分为      链表结构实现
 添加、删除元素 插入元素 获取链表长度、输出链表文本    双向链表
  循环链表
  排序链表
  通过链表实现栈
  链表结构实现     实现一个链表类，包含删除、添加元素、链表长度等
 class Node { constructor(value) { this.value = value this.next = null } } class LinkedList { count = 0 head = null push(element) { const node = new Node(element) if (this.isEmpty()) { this.</description>
    </item>
    
    <item>
      <title>数据结构 集合、字典、散列</title>
      <link>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88%E5%AD%97%E5%85%B8%E6%95%A3%E5%88%97/</link>
      <pubDate>Sat, 07 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88%E5%AD%97%E5%85%B8%E6%95%A3%E5%88%97/</guid>
      <description>集合     集合是一种存储不重复数据的结构，es5中set是具体实现
 集合实现    class Set { item = {}; add(key) { if (!this.has(key)) { this.item[key] = key return true } return false } remove(key) { if (this.has(key)) { delete this.item[key] return true } return false } // 并集  union(otherSet = {}) { const newSet = new Dictionary() this.values().forEach((item) =&amp;gt; newSet.add(item)) otherSet.values().forEach((item) =&amp;gt; newSet.add(item)) return newSet.values() } // 交集  intersect(otherSet = {}) { return this.</description>
    </item>
    
    <item>
      <title>数据结构 分类</title>
      <link>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E7%B1%BB/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E7%B1%BB/</guid>
      <description>数据结构与算法     本文件内所有知识点均是基础的数据结构与算法，具体参考每个章节markdown 后续深入理解，参考 初级算法 &amp;amp;&amp;amp; 中级算法 &amp;amp;&amp;amp; 高级算法 (大部分参考leetCode)  数据结构     栈： 一种遵从先进后出原则的有序集合；新添加或者待删除的元素都会保存的在栈的头部，称为栈顶，另一端为栈底，在栈里面，新元素都靠近栈顶，旧元素都接近栈底 队列： 与栈相反，遵从先进先出的原则的一组有序的项，队列在尾部添加新的元素，并从头部移除元素，最新添加的元素必须在队列的末尾  普通队列 优先队列 循环队列   链表： 存储有序的元素集合, 但不同与数组, 链表中元素在内存中并不是连续放置的; 每个元素由一个存储元素本身的节点和一个指向下一个元素引用(指针/链接)组成  普通链表 双向链表 循环链表   集合： 集合是一组无序且唯一的项组成，这个数据结构使用了与有限集合相同的数学概念 字典： 集合、字典、散列表都可以存储不重复的数据，字典和集合很像，集合是以{value: value}形式存储数据，而字典是以{key: value}形式存储数据，字典也称为映射(object对象便是字典在javascript中的实现) 散列： HashMap类是Dictionary的一种散列表实现方式， 散列算法是尽可能地在数据结构中快速找到一个值，使用散列函数，就知道 值的具体位置，因此能够快速检索到該值，散列函数的作用是给定一个键值，然后返回值在表中的地址。 树： TODO  栈    一种遵从先进后出原则的有序集合；新添加或者待删除的元素都会保存的在栈的头部，称为栈顶，另一端为栈底，在栈里面，新元素都靠近栈顶，旧元素都接近栈底
栈也被用在编程语言的编辑器和内存中保存变量，方法调用
队列    在现实中，最常见的例子就是排队，吃饭排队、银行业务排队、公车的前门上后门下机制&amp;hellip;，前面的人优先完成自己的事务，完成之后，下一个人才能继续。总之，遵从先出原则，
优先队列    其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。</description>
    </item>
    
    <item>
      <title>数据结构 队列篇</title>
      <link>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%E7%AF%87/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%E7%AF%87/</guid>
      <description>队列    队列是遵循先进先出的有序集合，在队列尾部添加新元素，队列首部移除元素，最新添加的元素加在队列尾部
Queue    // 对象模拟  class Queue { item = {} count = 0 lastIndex = 0 enqueue(value) { this.item[this.count] = value this.count++ } dequeue() { if (this.isEmpty()) { return undefined } const result = this.item[this.lastIndex] delete this.item[this.lastIndex] this.lastIndex++ return result } size() { return this.count - this.lastIndex } isEmpty() { return this.lastIndex === this.count } print() { let str = this.item[0] for (let i = 1; i &amp;lt; this.</description>
    </item>
    
    <item>
      <title>数据结构 堆栈篇</title>
      <link>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%A0%88%E7%AF%87/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%A0%88%E7%AF%87/</guid>
      <description>栈    是一种遵循后入先出的数据集合，新添加的元素靠近栈顶，后添加靠近栈底
用对象模拟栈    // 对象模拟  class Stack { constructor() { this.count = 0 this.item = {} } push(value) { this.item[this.count] = value this.count++ } peek() { if (this.isEmpty()) { return undefined } this.count-- const result = this.item[this.count] delete this.item[this.count] return result } isEmpty() { return this.count === 0 } size() { return this.count } print() { let str = this.item[0] for (let i = 1; i &amp;lt; this.</description>
    </item>
    
    <item>
      <title>levi-webpack总结</title>
      <link>https://nieshiming.cn/posts/levi-webpack%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/levi-webpack%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;webpack-模块打包原理&#34;&gt;
  webpack 模块打包原理
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e6%a8%a1%e5%9d%97%e6%89%93%e5%8c%85%e5%8e%9f%e7%90%86&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903802382860296#heading-5&#34;&gt;webpack 模块打包原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack-热更新原理&#34;&gt;
  webpack 热更新原理
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e7%83%ad%e6%9b%b4%e6%96%b0%e5%8e%9f%e7%90%86&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;h5 id=&#34;参考文章&#34;&gt;
  参考文章
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/30669007&#34;&gt;Webpack HMR 原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844904008432222215&#34;&gt;轻松理解webpack热更新原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6973825927708934174#comment&#34;&gt;120 行代码帮你了解 Webpack 下的 HMR 机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack-如何自定义loader实现思路如何&#34;&gt;
  webpack 如何自定义loader，实现思路如何
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e5%a6%82%e4%bd%95%e8%87%aa%e5%ae%9a%e4%b9%89loader%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af%e5%a6%82%e4%bd%95&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;带有副作用的内容转换器,函数, 从右到左执行，实质上是一个compose函数
将源文件经过转换输出新的结果，支持链式操作，其本质上就是一个函数&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>levi-react总结</title>
      <link>https://nieshiming.cn/posts/levi-react%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/levi-react%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;什么是虚拟dom怎么构成的&#34;&gt;
  什么是虚拟DOM，怎么构成的
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9fdom%e6%80%8e%e4%b9%88%e6%9e%84%e6%88%90%e7%9a%84&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div id&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;app&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;p &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;hello world&lt;span style=&#34;color:#ff79c6&#34;&gt;!!!&amp;lt;&lt;/span&gt;/p&amp;gt;
  &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;

  &lt;span style=&#34;color:#6272a4&#34;&gt;// 可转化成下面的虚拟DOM表示
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  {
    tag&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;,
    props&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; {
      id&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;
    },
    chidren&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; [
      {
        tag&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;,
        props&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; {
          className&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;text&amp;#39;&lt;/span&gt;
        },
        chidren&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; [
          &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;hello world!!!&amp;#39;&lt;/span&gt;
        ]
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>levi_http总结</title>
      <link>https://nieshiming.cn/posts/levi-http%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/levi-http%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;http-协商缓存--强制缓存&#34;&gt;
  http 协商缓存 &amp;amp; 强制缓存
  &lt;a class=&#34;heading-link&#34; href=&#34;#http-%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98--%e5%bc%ba%e5%88%b6%e7%bc%93%e5%ad%98&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903838768431118&#34;&gt;http面试必会的：强制缓存和协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000016199807&#34;&gt;10分钟彻底搞懂Http的强制缓存和协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;强缓存是利用http头部中的cache-control和expries控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;expries: (http1.0) 属于过时的验证缓存的方式，其值保存的是服务器返回的过期时间，再次发起请求的时候，如果客户端时间小于资源expires则不会发起请求   &lt;br&gt;
cache-control: (http1.1) 现在最多使用的控制缓存的方式，服务器返回的一个相对时间(会设置一个毫秒数，在有效时间内发起服务器请求，会读取缓存内容，直至失效，重新发起服务器请求)，解决expires比较时间造成的问题，请求服务器资源时，比较缓存资源时间和客户端当前时间(发生更改)，则会重新请求资源&lt;/p&gt;
&lt;p&gt;通常来说，强缓存不会向浏览器发起请求，直接从缓存中读取内容，在在chrome控制台的network的size选项中可以看到该请求返回200的状态码。分为 from disk cache 和 from memory cache。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from disk cache：（硬盘中缓存） 一般非脚本内容，例如css/html&lt;/li&gt;
&lt;li&gt;from memory cache: （内存中缓存）一般是脚本、字体、图片&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>levi-css总结</title>
      <link>https://nieshiming.cn/posts/levi-css%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/levi-css%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;flex&#34;&gt;
  flex
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;h5 id=&#34;flex-basis&#34;&gt;
  flex-basis
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex-basis&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;flex-basis: 项目占据主轴的宽度， 在分配多余空间之前会判断这个属性大小， 默认值auto&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;auto: 即项目本身的大小，取决于item自身的宽度或高度&lt;/li&gt;
&lt;li&gt;0%： 不暂居主轴宽度，item的宽度和高度无意义
&lt;strong&gt;当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;flex-grow&#34;&gt;
  flex-grow
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex-grow&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;flex-grow: 用于瓜分”父容器“剩余空间 。定义项目的放大比例， 默认值0，即存在剩余空间，也不会放大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)&lt;/li&gt;
&lt;li&gt;如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>JS基础汇总</title>
      <link>https://nieshiming.cn/posts/js%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</link>
      <pubDate>Thu, 23 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nieshiming.cn/posts/js%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;h4 id=&#34;01--02-为什么不等于-03&#34;&gt;
  0.1 + 0.2 为什么不等于 0.3
  &lt;a class=&#34;heading-link&#34; href=&#34;#01--02-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%ad%89%e4%ba%8e-03&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012175422&#34;&gt;为什么0.1+0.2不等于0.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/363133848&#34;&gt;非科班前端人的一道送命题：0.1+0.2 等于 0.3 吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在浏览器多数采用双精度即64存储浮点数
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1位： 符号位，正数0，负数1&lt;/li&gt;
&lt;li&gt;2-11位： 指数位阶数+偏移量，阶数是：2^e-1 - 1&lt;/li&gt;
&lt;li&gt;12-64: 小数位， 即二进制小数点后面的数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;0.1+0.2 不等于 0.3 ，因为在 0.1+0.2 的计算过程中发生了两次精度丢失。第一次是在 0.1 和 0.2 转成双精度二进制浮点数时，由于二进制浮点数的小数位只能存储52位，导致小数点后第53位的数要进行为1则进1为0则舍去的操作，从而造成一次精度丢失。第二次在 0.1 和 0.2 转成二进制浮点数后，二进制浮点数相加的过程中，小数位相加导致小数位多出了一位，又要让第53位的数进行为1则进1为0则舍去的操作，又造成一次精度丢失。最终导致 0.1+0.2 不等于0.3 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed var c = 0.1 + 0.2; c.toFixed(2) === &amp;ldquo;0.30&amp;rdquo;， 在做Number转换&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
