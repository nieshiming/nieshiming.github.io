<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on levi</title>
    <link>http://www.example.com/posts/</link>
    <description>Recent content in Posts on levi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 16 Dec 2021 13:28:22 +0800</lastBuildDate><atom:link href="http://www.example.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>levi-webpack总结</title>
      <link>http://www.example.com/posts/levi-webpack%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:28:22 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-webpack%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;webpack-模块打包原理&#34;&gt;
  webpack 模块打包原理
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e6%a8%a1%e5%9d%97%e6%89%93%e5%8c%85%e5%8e%9f%e7%90%86&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903802382860296#heading-5&#34;&gt;webpack 模块打包原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack-热更新原理&#34;&gt;
  webpack 热更新原理
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e7%83%ad%e6%9b%b4%e6%96%b0%e5%8e%9f%e7%90%86&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;h5 id=&#34;参考文章&#34;&gt;
  参考文章
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/30669007&#34;&gt;Webpack HMR 原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844904008432222215&#34;&gt;轻松理解webpack热更新原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6973825927708934174#comment&#34;&gt;120 行代码帮你了解 Webpack 下的 HMR 机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack-如何自定义loader实现思路如何&#34;&gt;
  webpack 如何自定义loader，实现思路如何
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e5%a6%82%e4%bd%95%e8%87%aa%e5%ae%9a%e4%b9%89loader%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af%e5%a6%82%e4%bd%95&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;带有副作用的内容转换器,函数, 从右到左执行，实质上是一个compose函数
将源文件经过转换输出新的结果，支持链式操作，其本质上就是一个函数&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>levi-react总结</title>
      <link>http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:27:27 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;什么是虚拟dom怎么构成的&#34;&gt;
  什么是虚拟DOM，怎么构成的
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9fdom%e6%80%8e%e4%b9%88%e6%9e%84%e6%88%90%e7%9a%84&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;  &amp;lt;div id=&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;app&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;p &lt;span style=&#34;font-weight:bold&#34;&gt;class&lt;/span&gt;=&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&amp;gt;hello world!!!&amp;lt;&lt;span style=&#34;&#34;&gt;/p&amp;gt;&lt;/span&gt;
  &amp;lt;&lt;span style=&#34;&#34;&gt;/div&amp;gt;&lt;/span&gt;

  &lt;span style=&#34;font-style:italic&#34;&gt;// 可转化成下面的虚拟DOM表示
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;  {
    tag: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;,
    props: {
      id: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;
    },
    chidren: [
      {
        tag: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;,
        props: {
          className: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;text&amp;#39;&lt;/span&gt;
        },
        chidren: [
          &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;hello world!!!&amp;#39;&lt;/span&gt;
        ]
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>levi_http总结</title>
      <link>http://www.example.com/posts/levi-http%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:26:42 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-http%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;http-协商缓存--强制缓存&#34;&gt;
  http 协商缓存 &amp;amp; 强制缓存
  &lt;a class=&#34;heading-link&#34; href=&#34;#http-%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98--%e5%bc%ba%e5%88%b6%e7%bc%93%e5%ad%98&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903838768431118&#34;&gt;http面试必会的：强制缓存和协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000016199807&#34;&gt;10分钟彻底搞懂Http的强制缓存和协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;强缓存是利用http头部中的cache-control和expries控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;expries: (http1.0) 属于过时的验证缓存的方式，其值保存的是服务器返回的过期时间，再次发起请求的时候，如果客户端时间小于资源expires则不会发起请求   &lt;br&gt;
cache-control: (http1.1) 现在最多使用的控制缓存的方式，服务器返回的一个相对时间(会设置一个毫秒数，在有效时间内发起服务器请求，会读取缓存内容，直至失效，重新发起服务器请求)，解决expires比较时间造成的问题，请求服务器资源时，比较缓存资源时间和客户端当前时间(发生更改)，则会重新请求资源&lt;/p&gt;
&lt;p&gt;通常来说，强缓存不会向浏览器发起请求，直接从缓存中读取内容，在在chrome控制台的network的size选项中可以看到该请求返回200的状态码。分为 from disk cache 和 from memory cache。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from disk cache：（硬盘中缓存） 一般非脚本内容，例如css/html&lt;/li&gt;
&lt;li&gt;from memory cache: （内存中缓存）一般是脚本、字体、图片&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>levi-css总结</title>
      <link>http://www.example.com/posts/levi-css%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:26:07 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-css%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;flex&#34;&gt;
  flex
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;h5 id=&#34;flex-basis&#34;&gt;
  flex-basis
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex-basis&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;flex-basis: 项目占据主轴的宽度， 在分配多余空间之前会判断这个属性大小， 默认值auto&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;auto: 即项目本身的大小，取决于item自身的宽度或高度&lt;/li&gt;
&lt;li&gt;0%： 不暂居主轴宽度，item的宽度和高度无意义
&lt;strong&gt;当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;flex-grow&#34;&gt;
  flex-grow
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex-grow&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;flex-grow: 用于瓜分”父容器“剩余空间 。定义项目的放大比例， 默认值0，即存在剩余空间，也不会放大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)&lt;/li&gt;
&lt;li&gt;如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>JS基础汇总</title>
      <link>http://www.example.com/posts/js%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</link>
      <pubDate>Thu, 16 Dec 2021 13:25:18 +0800</pubDate>
      
      <guid>http://www.example.com/posts/js%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;h4 id=&#34;01--02-为什么不等于-03&#34;&gt;
  0.1 + 0.2 为什么不等于 0.3
  &lt;a class=&#34;heading-link&#34; href=&#34;#01--02-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%ad%89%e4%ba%8e-03&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012175422&#34;&gt;为什么0.1+0.2不等于0.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/363133848&#34;&gt;非科班前端人的一道送命题：0.1+0.2 等于 0.3 吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在浏览器多数采用双精度即64存储浮点数
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1位： 符号位，正数0，负数1&lt;/li&gt;
&lt;li&gt;2-11位： 指数位阶数+偏移量，阶数是：2^e-1 - 1&lt;/li&gt;
&lt;li&gt;12-64: 小数位， 即二进制小数点后面的数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;0.1+0.2 不等于 0.3 ，因为在 0.1+0.2 的计算过程中发生了两次精度丢失。第一次是在 0.1 和 0.2 转成双精度二进制浮点数时，由于二进制浮点数的小数位只能存储52位，导致小数点后第53位的数要进行为1则进1为0则舍去的操作，从而造成一次精度丢失。第二次在 0.1 和 0.2 转成二进制浮点数后，二进制浮点数相加的过程中，小数位相加导致小数位多出了一位，又要让第53位的数进行为1则进1为0则舍去的操作，又造成一次精度丢失。最终导致 0.1+0.2 不等于0.3 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed var c = 0.1 + 0.2; c.toFixed(2) === &amp;ldquo;0.30&amp;rdquo;， 在做Number转换&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>git-pull-和git-fetch区别</title>
      <link>http://www.example.com/posts/git-pull-%E5%92%8Cgit-fetch%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 16 Dec 2021 13:24:46 +0800</pubDate>
      
      <guid>http://www.example.com/posts/git-pull-%E5%92%8Cgit-fetch%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;h4 id=&#34;描述&#34;&gt;
  描述
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%8f%8f%e8%bf%b0&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;git fetch并没有更新远程代码到本地仓库，只是拉去了远程的commit数据，将远程仓库的commitid 更新为lastet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;工作区&#34;&gt;
  工作区
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8c%ba&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;简而言之就是工作的区域，对于git而言，就是当前工作的目录，工作的内容会被提交到暂存区以及版本库中，同时也包含自己的修改的内容&lt;/p&gt;
&lt;h5 id=&#34;暂存区&#34;&gt;
  暂存区
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%9a%82%e5%ad%98%e5%8c%ba&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;使用git add 命令把我们工作区修改的内容添加到暂存区中&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git-入门指令</title>
      <link>http://www.example.com/posts/git-%E5%85%A5%E9%97%A8%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Thu, 16 Dec 2021 13:22:54 +0800</pubDate>
      
      <guid>http://www.example.com/posts/git-%E5%85%A5%E9%97%A8%E6%8C%87%E4%BB%A4/</guid>
      <description>&lt;h4 id=&#34;初始化连接-git-相关&#34;&gt;
  初始化连接 git 相关
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e8%bf%9e%e6%8e%a5-git-%e7%9b%b8%e5%85%b3&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;    git clone xxx(远程仓库名)            ---克隆项目
    git remote add origin xxx           ---本地仓库连接到远程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;配置账号密码&#34;&gt;
  配置账号密码
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e9%85%8d%e7%bd%ae%e8%b4%a6%e5%8f%b7%e5%af%86%e7%a0%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;    git config --local user.name xxx
    git config --local user.email &amp;#39;xxx@xx.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;git 配置推送时自动保存账号密码: &lt;code&gt;git config credential.helper store&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参考文章: &lt;a href=&#34;https://cloud.tencent.com/developer/ask/131910&#34;&gt;https://cloud.tencent.com/developer/ask/131910&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单个分支相关&#34;&gt;
  单个分支相关
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%8d%95%e4%b8%aa%e5%88%86%e6%94%af%e7%9b%b8%e5%85%b3&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建本地分支: git branch dev/nsm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除本地分支： git branch -D dev/nsm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换到本地分支： git checkout dev/nsm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换上一个分支： git checkout -&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建并切换到改分支： git checkout -b xxx&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>ByteDance八股文</title>
      <link>http://www.example.com/posts/bytedance%E5%85%AB%E8%82%A1%E6%96%87/</link>
      <pubDate>Thu, 16 Dec 2021 13:22:12 +0800</pubDate>
      
      <guid>http://www.example.com/posts/bytedance%E5%85%AB%E8%82%A1%E6%96%87/</guid>
      <description>&lt;p&gt;字节面经总结&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>单点登录</title>
      <link>http://www.example.com/posts/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</link>
      <pubDate>Thu, 16 Dec 2021 13:21:22 +0800</pubDate>
      
      <guid>http://www.example.com/posts/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</guid>
      <description>&lt;h4 id=&#34;1同域-sso&#34;&gt;
  1.同域 SSO
  &lt;a class=&#34;heading-link&#34; href=&#34;#1%e5%90%8c%e5%9f%9f-sso&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;如图，同域 SSO 是最简单的一种情况。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;此时，两个产品都是在一个域名下，单点登录是很自然的选择。我们来捋一捋步骤，搞清楚这里的步骤是理解后文的基础，千万不要跳过。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户访问产品 a，向 后台服务器发送登录请求。&lt;/li&gt;
&lt;li&gt;登录认证成功，服务器把用户的登录信息写入 session。服务器为该用户生成一个 cookie，并加入到 response header 中，随着请求返回而写入浏览器。该 cookie 的域设定为 dxy.cn。&lt;/li&gt;
&lt;li&gt;下一次，当用户访问同域名的产品 b 时，由于 a 和 b 在同一域名下，也是 dxy.cn，浏览器会自动带上之前的 cookie。此时后台服务器就可以通过该 cookie 来验证登录状态了。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>routerv5源码探析前端路由本质</title>
      <link>http://www.example.com/posts/routerv5%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%AC%E8%B4%A8/</link>
      <pubDate>Thu, 16 Dec 2021 13:18:14 +0800</pubDate>
      
      <guid>http://www.example.com/posts/routerv5%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%AC%E8%B4%A8/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;
  前言
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id=&#34;什么是前端路由&#34;&gt;
  什么是前端路由
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;首先，路由的概念开始是后端提出来的，用来跟服务器进行数据/资源获取的一种方式，通过不同的路径，来获取不同的资源
前端随着ajax(不刷新页面情况下请求数据)的流行，推动着异步交互体验提升，随后spa&amp;lt;单页面应用程序&amp;gt;在前端领域大放异彩&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spa: 单页面应用程序不仅在页面内交互是无刷新的，连页面之间的跳转也没有刷新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;spa核心思想&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听url变化&lt;/li&gt;
&lt;li&gt;改变context的值&lt;/li&gt;
&lt;li&gt;匹配相对应的组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现前端路由应该包括哪些功能&#34;&gt;
  实现前端路由应该包括哪些功能
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ba%94%e8%af%a5%e5%8c%85%e6%8b%ac%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;前端可以自己维护和控制浏览器的history&amp;lt;历史记录&amp;gt;。我们称之为history栈， 保证浏览器在url改变的时候不会刷新页面。并且通过history栈控制浏览器页面的前进和后退&lt;/p&gt;
&lt;p&gt;目前 Router有两种实现方式  hash 和 History&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>吃一堑长一智系列_babel基础知识</title>
      <link>http://www.example.com/posts/%E5%90%83%E4%B8%80%E5%A0%91%E9%95%BF%E4%B8%80%E6%99%BA%E7%B3%BB%E5%88%97_babel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 16 Dec 2021 13:17:23 +0800</pubDate>
      
      <guid>http://www.example.com/posts/%E5%90%83%E4%B8%80%E5%A0%91%E9%95%BF%E4%B8%80%E6%99%BA%E7%B3%BB%E5%88%97_babel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;p&gt;作为工具开发者，babel 关联问题是难绕过去的砍。
在 babel@6 时候，最常收到反馈之一就是 regeneratorRuntime is not defined
而到了 babel@7，最常收到反馈之一 Cannot find module &amp;lsquo;core-js/library/fn/**&amp;rsquo;.
那是什么问题导致这些问题的出现呢，我觉得有一个 issue 特别能代表这一类的开发者。大家不要笑，我们内部一些基础模块也有这个问题
&lt;strong&gt;总结来讲：Babel 在编译大家的代码时候，会依据大家配置的 preset or plugin 注入一些模块依赖，而这些模块依赖是大家需要在 pkg.dependencies 里面体现出来的，否则很可能出现的问题就是加载不到具体的文件或者加载错误的版本的文件。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git-代码提交规范</title>
      <link>http://www.example.com/posts/git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</link>
      <pubDate>Thu, 16 Dec 2021 11:44:47 +0800</pubDate>
      
      <guid>http://www.example.com/posts/git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</guid>
      <description>&lt;h4 id=&#34;代码提交规范&#34;&gt;
  代码提交规范
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e6%8f%90%e4%ba%a4%e8%a7%84%e8%8c%83&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;因为最近项目比较多，而且经常穿插各种很紧急的小需求，导致版本管理比较困难，所以现在定制一下代码的提交规范&lt;/p&gt;
&lt;h4 id=&#34;具体步骤&#34;&gt;
  具体步骤
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基于master分支，创建出自己的开发分支，分支命名可以参考 &lt;code&gt;feature-功能描述&lt;/code&gt; 或者 &lt;code&gt;bug-bug描述&lt;/code&gt; 或者 &lt;code&gt;develop-姓名&lt;/code&gt; 这样的模式。&lt;/li&gt;
&lt;li&gt;在自己的开发分支上修改代码，创建Commit。&lt;/li&gt;
&lt;li&gt;在开发完成之后，将自己本地的开发分支推送到远端，这时候需要确定自己的开发分支需要合并进哪个版本分支。&lt;/li&gt;
&lt;li&gt;在明确了版本分支之后，在GitLab上创建Merge Request。创建Merge Request的步骤如下：
&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
