<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>八股文 on levi</title>
    <link>http://www.example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/</link>
    <description>Recent content in 八股文 on levi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 16 Dec 2021 13:28:22 +0800</lastBuildDate><atom:link href="http://www.example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>levi-webpack总结</title>
      <link>http://www.example.com/posts/levi-webpack%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:28:22 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-webpack%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;webpack-模块打包原理&#34;&gt;
  webpack 模块打包原理
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e6%a8%a1%e5%9d%97%e6%89%93%e5%8c%85%e5%8e%9f%e7%90%86&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903802382860296#heading-5&#34;&gt;webpack 模块打包原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack-热更新原理&#34;&gt;
  webpack 热更新原理
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e7%83%ad%e6%9b%b4%e6%96%b0%e5%8e%9f%e7%90%86&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;h5 id=&#34;参考文章&#34;&gt;
  参考文章
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/30669007&#34;&gt;Webpack HMR 原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844904008432222215&#34;&gt;轻松理解webpack热更新原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6973825927708934174#comment&#34;&gt;120 行代码帮你了解 Webpack 下的 HMR 机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack-如何自定义loader实现思路如何&#34;&gt;
  webpack 如何自定义loader，实现思路如何
  &lt;a class=&#34;heading-link&#34; href=&#34;#webpack-%e5%a6%82%e4%bd%95%e8%87%aa%e5%ae%9a%e4%b9%89loader%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af%e5%a6%82%e4%bd%95&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;带有副作用的内容转换器,函数, 从右到左执行，实质上是一个compose函数
将源文件经过转换输出新的结果，支持链式操作，其本质上就是一个函数&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>levi-react总结</title>
      <link>http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:27:27 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-react%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;什么是虚拟dom怎么构成的&#34;&gt;
  什么是虚拟DOM，怎么构成的
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9fdom%e6%80%8e%e4%b9%88%e6%9e%84%e6%88%90%e7%9a%84&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;虚拟DOM是真实DOM在内存中的表示，简单来说，虚拟DOM就是个对象，由tag,props,children构成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;  &amp;lt;div id=&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;app&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;p &lt;span style=&#34;font-weight:bold&#34;&gt;class&lt;/span&gt;=&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&amp;gt;hello world!!!&amp;lt;&lt;span style=&#34;&#34;&gt;/p&amp;gt;&lt;/span&gt;
  &amp;lt;&lt;span style=&#34;&#34;&gt;/div&amp;gt;&lt;/span&gt;

  &lt;span style=&#34;font-style:italic&#34;&gt;// 可转化成下面的虚拟DOM表示
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;  {
    tag: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;,
    props: {
      id: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;
    },
    chidren: [
      {
        tag: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;,
        props: {
          className: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;text&amp;#39;&lt;/span&gt;
        },
        chidren: [
          &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;hello world!!!&amp;#39;&lt;/span&gt;
        ]
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面对象就是我们说的虚拟DOM，可表示成树形结构，原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>levi_http总结</title>
      <link>http://www.example.com/posts/levi-http%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:26:42 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-http%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;http-协商缓存--强制缓存&#34;&gt;
  http 协商缓存 &amp;amp; 强制缓存
  &lt;a class=&#34;heading-link&#34; href=&#34;#http-%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98--%e5%bc%ba%e5%88%b6%e7%bc%93%e5%ad%98&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903838768431118&#34;&gt;http面试必会的：强制缓存和协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000016199807&#34;&gt;10分钟彻底搞懂Http的强制缓存和协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;强缓存是利用http头部中的cache-control和expries控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;expries: (http1.0) 属于过时的验证缓存的方式，其值保存的是服务器返回的过期时间，再次发起请求的时候，如果客户端时间小于资源expires则不会发起请求   &lt;br&gt;
cache-control: (http1.1) 现在最多使用的控制缓存的方式，服务器返回的一个相对时间(会设置一个毫秒数，在有效时间内发起服务器请求，会读取缓存内容，直至失效，重新发起服务器请求)，解决expires比较时间造成的问题，请求服务器资源时，比较缓存资源时间和客户端当前时间(发生更改)，则会重新请求资源&lt;/p&gt;
&lt;p&gt;通常来说，强缓存不会向浏览器发起请求，直接从缓存中读取内容，在在chrome控制台的network的size选项中可以看到该请求返回200的状态码。分为 from disk cache 和 from memory cache。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from disk cache：（硬盘中缓存） 一般非脚本内容，例如css/html&lt;/li&gt;
&lt;li&gt;from memory cache: （内存中缓存）一般是脚本、字体、图片&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>levi-css总结</title>
      <link>http://www.example.com/posts/levi-css%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Dec 2021 13:26:07 +0800</pubDate>
      
      <guid>http://www.example.com/posts/levi-css%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h4 id=&#34;flex&#34;&gt;
  flex
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;h5 id=&#34;flex-basis&#34;&gt;
  flex-basis
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex-basis&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;flex-basis: 项目占据主轴的宽度， 在分配多余空间之前会判断这个属性大小， 默认值auto&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;auto: 即项目本身的大小，取决于item自身的宽度或高度&lt;/li&gt;
&lt;li&gt;0%： 不暂居主轴宽度，item的宽度和高度无意义
&lt;strong&gt;当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;flex-grow&#34;&gt;
  flex-grow
  &lt;a class=&#34;heading-link&#34; href=&#34;#flex-grow&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;flex-grow: 用于瓜分”父容器“剩余空间 。定义项目的放大比例， 默认值0，即存在剩余空间，也不会放大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)&lt;/li&gt;
&lt;li&gt;如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>JS基础汇总</title>
      <link>http://www.example.com/posts/js%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</link>
      <pubDate>Thu, 16 Dec 2021 13:25:18 +0800</pubDate>
      
      <guid>http://www.example.com/posts/js%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;h4 id=&#34;01--02-为什么不等于-03&#34;&gt;
  0.1 + 0.2 为什么不等于 0.3
  &lt;a class=&#34;heading-link&#34; href=&#34;#01--02-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%ad%89%e4%ba%8e-03&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012175422&#34;&gt;为什么0.1+0.2不等于0.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/363133848&#34;&gt;非科班前端人的一道送命题：0.1+0.2 等于 0.3 吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在浏览器多数采用双精度即64存储浮点数
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1位： 符号位，正数0，负数1&lt;/li&gt;
&lt;li&gt;2-11位： 指数位阶数+偏移量，阶数是：2^e-1 - 1&lt;/li&gt;
&lt;li&gt;12-64: 小数位， 即二进制小数点后面的数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;0.1+0.2 不等于 0.3 ，因为在 0.1+0.2 的计算过程中发生了两次精度丢失。第一次是在 0.1 和 0.2 转成双精度二进制浮点数时，由于二进制浮点数的小数位只能存储52位，导致小数点后第53位的数要进行为1则进1为0则舍去的操作，从而造成一次精度丢失。第二次在 0.1 和 0.2 转成二进制浮点数后，二进制浮点数相加的过程中，小数位相加导致小数位多出了一位，又要让第53位的数进行为1则进1为0则舍去的操作，又造成一次精度丢失。最终导致 0.1+0.2 不等于0.3 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed var c = 0.1 + 0.2; c.toFixed(2) === &amp;ldquo;0.30&amp;rdquo;， 在做Number转换&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
